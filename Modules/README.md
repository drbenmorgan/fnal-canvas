Art's Custom CMake Modules
==========================
Notes on Art's custom cmake modules to help in decoding what these do
(or more specifically, the functions and macros they provide).

Document this in a separate file to keep things in one place and not
to modify the core files. There will be some reference to the source
tree under art/ because it's from here that we'll find uses of the
functions and macros.

Inclusion Order/Dependencies
============================
Art use cetbuildtools, so often calls into that, with usage marked by
"CBT::"

- ArtDictionary.cmake
  - CBT::BuildDictionary
  - CheckClassVersion.cmake
- ArtMake.cmake
  - ArtDictionary.cmake
  - CBT::CetMake
  - CBT::CetParseArgs
  - CBT::InstallSource
- BuildPlugins.cmake
  - CBT::BasicPlugin.cmake
- CheckClassVersion.cmake
  - CBT::CetParseArgs.cmake

Will need to check for other usage of CBT/Cetpkgsupport modules (e.g.
"artmod" from cetpkgsupport (that is simple code generation, so may not
be critical, though should be in art itself!!).

Usage in Art Components
=======================
art/Version
-----------
Calls `art_make_library`, `install_headers` and `install_source`.

art/Utilities
-------------
Calls `art_make`, `install_headers` and `install_source`.

Location/Purpose of CMake Functions/Macros
==========================================
Using the above section on Usage, try and drill down through the layers
of calls and see what underlying CMake functionality is actually wrapped.
List ordering at any point may be arbitrary, though would like to
aim from lowest to highest calls.

Stuff from CetBuildTools
------------------------
- `install_headers` : `CBT::InstallSource.cmake`
  - Globbing with hardcoding, relies of directory structure to function,
    nothing more than wrapper around `install(FILES ...)`.
- `install_sources` : `CBT::InstallSource.cmake`
  - Basically performs the task that a basic CPack setup should do.
    May install generated sources as well, but no real need to do
    this.
- `simple_plugin` : `CBT::BasicPlugin.cmake`
  - Basically a wrapper around `add_library`, `target_link_libraries` and
    `install`.
  - Name of plugin either set directly as `<name>_<type>` or derived
    from the path to the directory where it was called from.
    - Makes it sensitive to directory names, as these can't have
      underscores for the derived name to work
  - Always have one source file to generate one plugin.
    - source file expected to be named `<name>_<type>.cc`
    - call to `aad_library` with derived target names and this file,
      always a SHARED library type.
  - Then creates list of libraries to link to
    - uses supplied libs, and copies code from `cet_make_library`
      to process items in the based on path/name/uppercase.
    - Uses `find_tbb_offloads` as in `cet_make_library`.
    - Can specify the `USE_BOOST_UNIT` to compile/link to Boost.Unit...
  - If plugin to be installed, then its destination is `${flavorqual_dir}/lib`
- `cet_make_library` : `CBT::CetMake.cmake`
  - Basically a wrapper around `add_library/target_link_libraries/install`
  - Plus a flag to handle NO_INSTALL (i.e. alocal/test library)
  - Plus a flag to handle adding a static library as well.
  - Takes a source list, so no globbing.
  - It uses some command `find_tbb_offloads`. Appears that this checks
    sources for something, then modifies LINK_FLAGS property of target
    if check suceeds. Cannot find command to check what it does though...
  - Some odd processing of the LIBRARIES list (what it gets linked to).
    All libs are added, but some are converted to upper case names. Not
    at all clear why this is done.
  - Calls `cet_add_to_library_list` with library name as argument.
    That just adds the name to an internally cached list variable.
  - If installed, destination is set to "product" based paths.
- `build_dictionary` : `CBT::BuildDictionary.cmake`
  - If no dictionary name supplied, derives it from current source dir
  - Always appends ROOT Core and Reflex libs to link list
  - calls `_generate_dictionary` with dictionary name as arg
  - Uses files `<dictname>_{dict,map}.cpp` generated by the macro
    to compile **TWO** libraries, one for each file:
    - `<dictname>_dict`
    - `<dictname>_map`
    - Both libs have their `COMPILE_FLAGS` properties appended
      with any args passed in through `COMPILE_FLAGS` arg of `build_directory
    - `<dictname>_map` is made to depend on `<dictname>_dict`
    - They are both linked to the libraries derived above.
    - They are both installed to `flavorqual_dir/lib` unless the `NO_INSTALL`
      option was passed.
- `_generate_dictionary` : `CBT::BuildDictionary.cmake`
  - Basically wraps creation of `add_custom_command` that calls, in turn
    - genreflex to create ...
    - cmake to copy `classes_ids.cc` to `<dictname>_map.cpp`
    - cmake to remove `classes_ids.cc`
  - Genreflex is called with a set of flags, derived as:
    - Core, always applied (set at top of module).
      - These explicitly use g++ and GNU macros.
    - Appends `--dataonly` if `DICT_FUNCTIONS` option not set
    - Appends `-I <dir>` for every dir in `INCLUDE_DIRECTORIES` property
      of current source directory
    - Appends `-D<def>` for every def in `COMPILE_DEFINITIONS` property
      of current source directory
  - The resultant `add_custom_command` is then
    - `genreflex classes.h -s classes_def.xml <-I-Dargs> -o <dictname>_dict.cpp`
    - Note that it assumes that `classes{.h,_def.xml}` are in the current
      cmake sourc directory.
    - It also adds `-I` arguments for the CMake top level and current source
      directories.
    - It runs in the current binary directory.
  - NB: **If** a variable named `GENREFLEX_CLEANUP` is true, then a
    shell OR is used after the call to genreflex which removes
    the `<dictname>_dict.cpp` file.
    - This variable appears to be set in `find_ups_root`

Stuff from Art
--------------
- `_art_simple_plugin` : `ArtMake.cmake`
  - Basically a wrapper around `simple_plugin`
  - Takes `file`, `type` and list of link libraries as input and
    adapts these to the interface of `simple_plugin`
- `check_class_version` : [`CheckClassVersion.cmake`](CheckClassVersion.cmak)
  - Inclusion of `CheckClassVersion.cmake` results in a check for Python
    support in ROOT via running `root-config`. This sets a variable
    later used to protect the call to `checkClassVersion`
  - Wraps the [`checkClassVersion`](../tools/checkClassVersion) script
    inside `add_custom_target`
    - NB: [the CMake script in tools](../tools/CMakeLists.txt) uses
      `cet_script` to make an imported target for `checkClassVersion`
  - Takes LIBRARIES arg, but using this results in FATAL_ERROR (not supported yet...)
  - Takes UPDATE_IN_PLACE option which if set results in "-G" argument
    being passed to `checkClassVersion` script
  - Relies on local variable `dictname` being set prior to macro
    invocation (does FATAL_ERROR if not set), so can only be called
    after a `build_dictionary` call.
  - Custom target only created if earlier check on ROOT Python support
    was successful
    - Runs `checkClassVersion` script using any passed down arguments,
      a "-l" argument set to path to `lib<dictname>_dict` and a "-x"
      argument set to `classes_def.xml` which must be in the source
      directory from which the macro was invoked.
    - Target gets dependencies on `classes_def.xml`, `<dictname>_dict`
      `art_Framework_Core` and `checkClassVersion`
- `art_dictionary` : `ArtDictionary.cmake`
  - Wraps calls to `build_dictionary` and `check_class_version`
- `art_make_library` : `ArtMake.cmake`
  - Basically a wrapper around `cet_make_library`.
  - Can supply a name for the library, otherwise derived from current
    directory path from cmake (not project!) source dir.
  - Has to be supplied with source code list
  - Can supply a variable that gets set to the library name in the calling
    scope. Does not appear to be used within art.
  - Calls `cet_make_library` with the library name, source list,
    LIBRARIES list (if it was supplied) plus all other arguments.
- `art_make` : `ArtMake.cmake`
  - Basically a wrapper around `art_make_library`, `_art_simple_plugin`
    and `art_dictionary`.
  - Begins by globbing for library/plugin sources...
    - Appears that plugin sources must be named `<something>_<type>.cc`
      where `<type>` is `source`, `module` or `service` (possibly others,
      as list is appended via some unclear calculations).
    - Several globs over everything, then more specific patterns, then
      subdirectories.
    - Then filters out specific from general...
    - Also has an `EXCLUDES` argument to filter out user specified.
    - Almost certainly easier and less error prone to move to explicit
      listing...
  - Some processing of file lists occurs, but seems overly complex
    - Appears that a nested loop is used when a simple list set/copy
      would suffice (see `art_file_list` and `art_make_library_src`
      variables).
  - Need to build library indicated by non-empty `art_file_list` and
    `art_make_library_src`
    - Calls down to `art_make_library` with source list being the
      `art_make_library_src` variable, which appears equal to the
      `art_file_list` variable.
  - Plugin build activated if `NO_PLUGINS` is false and the `plugin_files`
    list is non empty.
    - Each file has the plugin type extracted and then passed to
      `_art_simple_plugin` with the type and and type specific libs.
 - Check for dictionary performed by globbing for `classes.h` and
   `classes_def.xml` files.
   - If these exist, it appends them to `art_file_list`
   - If a library was built, it's appended to `art_make_dict_libraries`,
     followed by any further `DICT_LIBRARIES`.
   - A call is then made to `art_dictionary`, with
     `art_make_dict_libraries` if it exists.

